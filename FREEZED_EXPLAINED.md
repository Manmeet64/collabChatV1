# Understanding Freezed and Generated Files (.g.dart, .freezed.dart)

## What is Freezed?

**Freezed** is a code generation package for Dart/Flutter that automatically generates:

- Immutable classes (classes whose values can't be changed after creation)
- `copyWith` methods (create modified copies of objects)
- JSON serialization/deserialization
- Equality operators (`==` and `hashCode`)
- `toString()` methods

## Why Use Freezed?

### Without Freezed (Manual Code):

```dart
class Message {
  final String id;
  final String senderId;
  final String content;
  final DateTime createdAt;

  Message({
    required this.id,
    required this.senderId,
    required this.content,
    required this.createdAt,
  });

  // Must manually write fromJson
  factory Message.fromJson(Map<String, dynamic> json) {
    return Message(
      id: json['_id'] as String,
      senderId: json['senderId'] as String,
      content: json['content'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
    );
  }

  // Must manually write toJson
  Map<String, dynamic> toJson() {
    return {
      '_id': id,
      'senderId': senderId,
      'content': content,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  // Must manually write copyWith
  Message copyWith({
    String? id,
    String? senderId,
    String? content,
    DateTime? createdAt,
  }) {
    return Message(
      id: id ?? this.id,
      senderId: senderId ?? this.senderId,
      content: content ?? this.content,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  // Must manually write equality
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Message &&
      other.id == id &&
      other.senderId == senderId &&
      other.content == content &&
      other.createdAt == createdAt;
  }

  @override
  int get hashCode {
    return id.hashCode ^ senderId.hashCode ^ content.hashCode ^ createdAt.hashCode;
  }

  @override
  String toString() {
    return 'Message(id: $id, senderId: $senderId, content: $content, createdAt: $createdAt)';
  }
}
```

**Total: ~80 lines of boilerplate code** üò´

### With Freezed (Automatic Generation):

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_model.freezed.dart';
part 'message_model.g.dart';

@freezed
class Message with _$Message {
  const factory Message({
    @JsonKey(name: '_id') required String id,
    required String senderId,
    required String content,
    required DateTime createdAt,
  }) = _Message;

  factory Message.fromJson(Map<String, dynamic> json) =>
      _$MessageFromJson(json);
}
```

**Total: ~15 lines** üéâ

All the boilerplate (fromJson, toJson, copyWith, ==, hashCode, toString) is **automatically generated**!

## Understanding the Files

### Your Source File: `message_model.dart`

This is the file **you write** - contains only the model definition:

```dart
@freezed
class Message with _$Message {
  const factory Message({...}) = _Message;
  factory Message.fromJson(...) => _$MessageFromJson(json);
}
```

### Generated File 1: `message_model.g.dart`

- Generated by `json_serializable` package
- Contains JSON serialization code:
    - `_$MessageFromJson()` - converts JSON ‚Üí Dart object
    - `_$MessageToJson()` - converts Dart object ‚Üí JSON
- **Never edit this file** - it's regenerated automatically

### Generated File 2: `message_model.freezed.dart`

- Generated by `freezed` package
- Contains:
    - `_$Message` class implementation
    - `copyWith()` method
    - `==` operator and `hashCode`
    - `toString()` method
- **Never edit this file** - it's regenerated automatically

## How Code Generation Works

1. **You write**: `message_model.dart` (15 lines)
2. **You run**: `dart run build_runner build`
3. **Generator creates**:
    - `message_model.g.dart` (JSON serialization)
    - `message_model.freezed.dart` (immutable class + utilities)

### Build Runner Commands:

```bash
# Generate files once
dart run build_runner build

# Generate and delete conflicting files
dart run build_runner build --delete-conflicting-outputs

# Watch for changes and auto-regenerate
dart run build_runner watch

# Clean generated files
dart run build_runner clean
```

## When to Regenerate?

Run `dart run build_runner build` when you:

- ‚úÖ Add/remove/modify fields in model
- ‚úÖ Change `@JsonKey` annotations
- ‚úÖ Add new models with `@freezed`
- ‚úÖ Get errors about missing generated code

## Benefits of Freezed

### 1. **Less Boilerplate**

Write 15 lines instead of 80+ lines per model

### 2. **Immutability by Default**

```dart
final msg = Message(id: '1', content: 'Hi');
// msg.content = 'Bye'; // ‚ùå Error - can't modify
final newMsg = msg.copyWith(content: 'Bye'); // ‚úÖ Create new instance
```

### 3. **Type-Safe JSON Conversion**

```dart
// Parse JSON safely
final message = Message.fromJson(jsonData);

// Convert to JSON
final json = message.toJson();
```

### 4. **Easy Copying with Changes**

```dart
final original = Message(id: '1', content: 'Hi', senderId: 'user1');
final modified = original.copyWith(content: 'Hello');
// id and senderId stay the same, only content changes
```

### 5. **Proper Equality**

```dart
final msg1 = Message(id: '1', content: 'Hi');
final msg2 = Message(id: '1', content: 'Hi');
print(msg1 == msg2); // ‚úÖ true (compares values, not references)
```

### 6. **Better Debugging**

```dart
print(message);
// Output: Message(id: 1, senderId: user123, content: Hello, createdAt: 2026-02-09...)
```

## Common Annotations

### `@freezed`

Marks a class for code generation

### `@JsonKey(name: '...')`

Maps JSON field name to Dart property:

```dart
@JsonKey(name: '_id') String id  // JSON has "_id", Dart uses "id"
```

### `@Default(...)`

Sets default value:

```dart
@Default('text') String type  // Default value is 'text'
```

### `@JsonKey(includeFromJson: false)`

Exclude field from JSON deserialization

## Your Project's Models

In your project, you have:

- `message_model.dart` + generated files
- `user_model.dart` + generated files
- `group_model.dart` + generated files
- `auth_response_model.dart` + generated files

Each follows the same pattern:

1. You write `.dart` with `@freezed`
2. Generator creates `.freezed.dart` and `.g.dart`
3. You never edit generated files
4. You regenerate when you change the model

## Summary

**Freezed + json_serializable = Less Code + More Features**

‚úÖ **Write once**: Simple model definition  
‚úÖ **Generate automatically**: All boilerplate code  
‚úÖ **Type-safe**: Compile-time checks  
‚úÖ **Immutable**: Can't accidentally modify data  
‚úÖ **Easy updates**: Just regenerate when needed

Think of it as a **code factory** - you provide the blueprint (your model), and it manufactures all the necessary code for you!
